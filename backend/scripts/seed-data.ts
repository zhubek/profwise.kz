import axios from 'axios';
import { PrismaClient, OrganizationType, QuestionType } from '@prisma/client';

const API_URL = 'http://localhost:4000';
const prisma = new PrismaClient();

// Axios instance with error handling
const api = axios.create({
  baseURL: API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Color codes for console output
const colors = {
  reset: '\x1b[0m',
  green: '\x1b[32m',
  blue: '\x1b[34m',
  yellow: '\x1b[33m',
  red: '\x1b[31m',
  cyan: '\x1b[36m',
};

function log(message: string, color: string = colors.reset) {
  console.log(`${color}${message}${colors.reset}`);
}

// Store created IDs
const createdIds = {
  regions: [] as string[],
  users: [] as string[],
  categories: [] as string[],
  professions: [] as string[],
  archetypeTypes: [] as string[],
  archetypes: [] as string[],
  quizzes: [] as string[],
  organizations: [] as string[],
  licenseClasses: [] as string[],
  licenses: [] as string[],
  specs: [] as string[],
  universities: [] as string[],
  questions: [] as string[],
  testScoreTypes: [] as string[],
};

async function createRegions() {
  log('\nüìç Creating Regions (via Prisma)...', colors.cyan);

  const regions = [
    {
      name: {
        en: 'Almaty Region',
        ru: '–ê–ª–º–∞—Ç–∏–Ω—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å',
        kk: '–ê–ª–º–∞—Ç—ã –æ–±–ª—ã—Å—ã',
      },
    },
    {
      name: {
        en: 'Astana City',
        ru: '–ì–æ—Ä–æ–¥ –ê—Å—Ç–∞–Ω–∞',
        kk: '–ê—Å—Ç–∞–Ω–∞ “õ–∞–ª–∞—Å—ã',
      },
    },
    {
      name: {
        en: 'Almaty City',
        ru: '–ì–æ—Ä–æ–¥ –ê–ª–º–∞—Ç—ã',
        kk: '–ê–ª–º–∞—Ç—ã “õ–∞–ª–∞—Å—ã',
      },
    },
  ];

  for (const region of regions) {
    try {
      const created = await prisma.region.create({ data: region });
      createdIds.regions.push(created.id);
      log(`‚úì Created region: ${region.name.en}`, colors.green);
    } catch (error: any) {
      log(`‚úó Failed to create region: ${error.message}`, colors.red);
    }
  }
}

async function createUsers() {
  log('\nüë• Creating Users...', colors.cyan);

  const users = [
    {
      name: '–ê–π–¥–∞—Ä',
      surname: '–ù“±—Ä—Å—É–ª—Ç–∞–Ω–æ–≤',
      email: 'aidar.nursultanov@example.kz',
      grade: '11',
      age: 17,
    },
    {
      name: '–ú–∞—Ä–∏—è',
      surname: '–ü–µ—Ç—Ä–æ–≤–∞',
      email: 'maria.petrova@example.ru',
      grade: '10',
      age: 16,
    },
    {
      name: '–î–∞–Ω–∏—è—Ä',
      surname: '“ö–∞—Å—ã–º–æ–≤',
      email: 'daniyar.kassymov@example.kz',
      grade: '11',
      age: 17,
    },
    {
      name: 'Sarah',
      surname: 'Johnson',
      email: 'sarah.johnson@example.com',
      grade: '12',
      age: 18,
    },
    {
      name: '–ê–Ω–Ω–∞',
      surname: '–ò–≤–∞–Ω–æ–≤–∞',
      email: 'anna.ivanova@example.ru',
      grade: '9',
      age: 15,
    },
  ];

  for (const user of users) {
    try {
      const response = await api.post('/users', user);
      createdIds.users.push(response.data.id);
      log(`‚úì Created user: ${user.name} ${user.surname}`, colors.green);
    } catch (error: any) {
      log(`‚úó Failed to create user: ${error.message}`, colors.red);
    }
  }
}

async function createCategories() {
  log('\nüìÅ Creating Categories (via Prisma)...', colors.cyan);

  const categories = [
    {
      name: {
        en: 'Technology & IT',
        ru: '–¢–µ—Ö–Ω–æ–ª–æ–≥–∏–∏ –∏ –ò–¢',
        kk: '–¢–µ—Ö–Ω–æ–ª–æ–≥–∏—è –∂”ô–Ω–µ IT',
      },
      description: {
        en: 'Careers in technology, software, and information systems',
        ru: '–ö–∞—Ä—å–µ—Ä–∞ –≤ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—è—Ö, –ø—Ä–æ–≥—Ä–∞–º–º–Ω–æ–º –æ–±–µ—Å–ø–µ—á–µ–Ω–∏–∏ –∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—ã—Ö —Å–∏—Å—Ç–µ–º–∞—Ö',
        kk: '–¢–µ—Ö–Ω–æ–ª–æ–≥–∏—è, –±–∞“ì–¥–∞—Ä–ª–∞–º–∞–ª—ã“õ “õ–∞–º—Ç–∞–º–∞—Å—ã–∑ –µ—Ç—É –∂”ô–Ω–µ –∞“õ–ø–∞—Ä–∞—Ç—Ç—ã“õ –∂“Ø–π–µ–ª–µ—Ä–¥–µ–≥—ñ –º–∞–Ω—Å–∞–ø',
      },
    },
    {
      name: {
        en: 'Healthcare & Medicine',
        ru: '–ó–¥—Ä–∞–≤–æ–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏ –ú–µ–¥–∏—Ü–∏–Ω–∞',
        kk: '–î–µ–Ω—Å–∞—É–ª—ã“õ —Å–∞“õ—Ç–∞—É –∂”ô–Ω–µ –ú–µ–¥–∏—Ü–∏–Ω–∞',
      },
      description: {
        en: 'Medical professions and healthcare services',
        ru: '–ú–µ–¥–∏—Ü–∏–Ω—Å–∫–∏–µ –ø—Ä–æ—Ñ–µ—Å—Å–∏–∏ –∏ —É—Å–ª—É–≥–∏ –∑–¥—Ä–∞–≤–æ–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è',
        kk: '–ú–µ–¥–∏—Ü–∏–Ω–∞–ª—ã“õ –º–∞–º–∞–Ω–¥—ã“õ—Ç–∞—Ä –∂”ô–Ω–µ –¥–µ–Ω—Å–∞—É–ª—ã“õ —Å–∞“õ—Ç–∞—É “õ—ã–∑–º–µ—Ç—Ç–µ—Ä—ñ',
      },
    },
    {
      name: {
        en: 'Business & Finance',
        ru: '–ë–∏–∑–Ω–µ—Å –∏ –§–∏–Ω–∞–Ω—Å—ã',
        kk: '–ë–∏–∑–Ω–µ—Å –∂”ô–Ω–µ “ö–∞—Ä–∂—ã',
      },
      description: {
        en: 'Business management, finance, and economics',
        ru: '–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –±–∏–∑–Ω–µ—Å–æ–º, —Ñ–∏–Ω–∞–Ω—Å—ã –∏ —ç–∫–æ–Ω–æ–º–∏–∫–∞',
        kk: '–ë–∏–∑–Ω–µ—Å—Ç—ñ –±–∞—Å“õ–∞—Ä—É, “õ–∞—Ä–∂—ã –∂”ô–Ω–µ —ç–∫–æ–Ω–æ–º–∏–∫–∞',
      },
    },
    {
      name: {
        en: 'Arts & Design',
        ru: '–ò—Å–∫—É—Å—Å—Ç–≤–æ –∏ –î–∏–∑–∞–π–Ω',
        kk: '”®–Ω–µ—Ä –∂”ô–Ω–µ –î–∏–∑–∞–π–Ω',
      },
      description: {
        en: 'Creative professions in arts, design, and media',
        ru: '–¢–≤–æ—Ä—á–µ—Å–∫–∏–µ –ø—Ä–æ—Ñ–µ—Å—Å–∏–∏ –≤ –∏—Å–∫—É—Å—Å—Ç–≤–µ, –¥–∏–∑–∞–π–Ω–µ –∏ –º–µ–¥–∏–∞',
        kk: '”®–Ω–µ—Ä, –¥–∏–∑–∞–π–Ω –∂”ô–Ω–µ –º–µ–¥–∏–∞–¥–∞“ì—ã —à—ã“ì–∞—Ä–º–∞—à—ã–ª—ã“õ –º–∞–º–∞–Ω–¥—ã“õ—Ç–∞—Ä',
      },
    },
    {
      name: {
        en: 'Education & Teaching',
        ru: '–û–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –∏ –ü—Ä–µ–ø–æ–¥–∞–≤–∞–Ω–∏–µ',
        kk: '–ë—ñ–ª—ñ–º –∂”ô–Ω–µ –û“õ—ã—Ç—É',
      },
      description: {
        en: 'Teaching and educational services',
        ru: '–ü—Ä–µ–ø–æ–¥–∞–≤–∞–Ω–∏–µ –∏ –æ–±—Ä–∞–∑–æ–≤–∞—Ç–µ–ª—å–Ω—ã–µ —É—Å–ª—É–≥–∏',
        kk: '–û“õ—ã—Ç—É –∂”ô–Ω–µ –±—ñ–ª—ñ–º –±–µ—Ä—É “õ—ã–∑–º–µ—Ç—Ç–µ—Ä—ñ',
      },
    },
  ];

  for (const category of categories) {
    try {
      const created = await prisma.category.create({ data: category });
      createdIds.categories.push(created.id);
      log(`‚úì Created category: ${category.name.en}`, colors.green);
    } catch (error: any) {
      log(`‚úó Failed to create category: ${error.message}`, colors.red);
    }
  }
}

async function createProfessions() {
  log('\nüíº Creating Professions...', colors.cyan);

  const professions = [
    {
      name: {
        en: 'Software Engineer',
        ru: '–ò–Ω–∂–µ–Ω–µ—Ä-–ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç',
        kk: '–ë–∞“ì–¥–∞—Ä–ª–∞–º–∞–ª—ã“õ –∏–Ω–∂–µ–Ω–µ—Ä',
      },
      description: {
        en: 'Designs, develops, and maintains software applications and systems',
        ru: '–ü—Ä–æ–µ–∫—Ç–∏—Ä—É–µ—Ç, —Ä–∞–∑—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∏ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –ø—Ä–æ–≥—Ä–∞–º–º–Ω—ã–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –∏ —Å–∏—Å—Ç–µ–º—ã',
        kk: '–ë–∞“ì–¥–∞—Ä–ª–∞–º–∞–ª—ã“õ “õ–æ—Å—ã–º—à–∞–ª–∞—Ä –º–µ–Ω –∂“Ø–π–µ–ª–µ—Ä–¥—ñ –∂–æ–±–∞–ª–∞–π–¥—ã, ”ô–∑—ñ—Ä–ª–µ–π–¥—ñ –∂”ô–Ω–µ “õ–æ–ª–¥–∞–π–¥—ã',
      },
      code: 'SE001',
      categoryId: createdIds.categories[0],
      featured: true,
    },
    {
      name: {
        en: 'Data Scientist',
        ru: '–°–ø–µ—Ü–∏–∞–ª–∏—Å—Ç –ø–æ –¥–∞–Ω–Ω—ã–º',
        kk: '–î–µ—Ä–µ–∫—Ç–µ—Ä –º–∞–º–∞–Ω—ã',
      },
      description: {
        en: 'Analyzes complex data to help organizations make better decisions',
        ru: '–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç —Å–ª–æ–∂–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –ø–æ–º–æ—â–∏ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è–º –≤ –ø—Ä–∏–Ω—è—Ç–∏–∏ —Ä–µ—à–µ–Ω–∏–π',
        kk: '“∞–π—ã–º–¥–∞—Ä“ì–∞ –∂–∞“õ—Å—ã —à–µ—à—ñ–º–¥–µ—Ä “õ–∞–±—ã–ª–¥–∞—É“ì–∞ –∫”©–º–µ–∫—Ç–µ—Å—É “Ø—à—ñ–Ω –∫“Ø—Ä–¥–µ–ª—ñ –¥–µ—Ä–µ–∫—Ç–µ—Ä–¥—ñ —Ç–∞–ª–¥–∞–π–¥—ã',
      },
      code: 'DS001',
      categoryId: createdIds.categories[0],
      featured: true,
    },
    {
      name: {
        en: 'Medical Doctor',
        ru: '–í—Ä–∞—á',
        kk: '–î”ô—Ä—ñ–≥–µ—Ä',
      },
      description: {
        en: 'Diagnoses and treats illnesses and injuries',
        ru: '–î–∏–∞–≥–Ω–æ—Å—Ç–∏—Ä—É–µ—Ç –∏ –ª–µ—á–∏—Ç –∑–∞–±–æ–ª–µ–≤–∞–Ω–∏—è –∏ —Ç—Ä–∞–≤–º—ã',
        kk: '–ê—É—Ä—É–ª–∞—Ä –º–µ–Ω –∂–∞—Ä–∞“õ–∞—Ç—Ç–∞—Ä–¥—ã –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞–ª–∞–π–¥—ã –∂”ô–Ω–µ –µ–º–¥–µ–π–¥—ñ',
      },
      code: 'MD001',
      categoryId: createdIds.categories[1],
      featured: true,
    },
    {
      name: {
        en: 'Financial Analyst',
        ru: '–§–∏–Ω–∞–Ω—Å–æ–≤—ã–π –∞–Ω–∞–ª–∏—Ç–∏–∫',
        kk: '“ö–∞—Ä–∂—ã–ª—ã“õ —Ç–∞–ª–¥–∞—É—à—ã',
      },
      description: {
        en: 'Analyzes financial data and provides investment recommendations',
        ru: '–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç —Ñ–∏–Ω–∞–Ω—Å–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –∏ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç –∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–æ–Ω–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏',
        kk: '“ö–∞—Ä–∂—ã–ª—ã“õ –¥–µ—Ä–µ–∫—Ç–µ—Ä–¥—ñ —Ç–∞–ª–¥–∞–π–¥—ã –∂”ô–Ω–µ –∏–Ω–≤–µ—Å—Ç–∏—Ü–∏—è–ª—ã“õ “±—Å—ã–Ω—ã—Å—Ç–∞—Ä –±–µ—Ä–µ–¥—ñ',
      },
      code: 'FA001',
      categoryId: createdIds.categories[2],
      featured: false,
    },
    {
      name: {
        en: 'Graphic Designer',
        ru: '–ì—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–π –¥–∏–∑–∞–π–Ω–µ—Ä',
        kk: '–ì—Ä–∞—Ñ–∏–∫–∞–ª—ã“õ –¥–∏–∑–∞–π–Ω–µ—Ä',
      },
      description: {
        en: 'Creates visual concepts to communicate ideas that inspire and inform',
        ru: '–°–æ–∑–¥–∞–µ—Ç –≤–∏–∑—É–∞–ª—å–Ω—ã–µ –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏ –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ –∏–¥–µ–π, –∫–æ—Ç–æ—Ä—ã–µ –≤–¥–æ—Ö–Ω–æ–≤–ª—è—é—Ç –∏ –∏–Ω—Ñ–æ—Ä–º–∏—Ä—É—é—Ç',
        kk: '–®–∞–±—ã—Ç—Ç–∞–Ω–¥—ã—Ä–∞—Ç—ã–Ω –∂”ô–Ω–µ —Ö–∞–±–∞—Ä–ª–∞–π—Ç—ã–Ω –∏–¥–µ—è–ª–∞—Ä–¥—ã –∂–µ—Ç–∫—ñ–∑—É “Ø—à—ñ–Ω –≤–∏–∑—É–∞–ª–¥—ã —Ç“±–∂—ã—Ä—ã–º–¥–∞–º–∞–ª–∞—Ä –∂–∞—Å–∞–π–¥—ã',
      },
      code: 'GD001',
      categoryId: createdIds.categories[3],
      featured: false,
    },
    {
      name: {
        en: 'High School Teacher',
        ru: '–£—á–∏—Ç–µ–ª—å —Å—Ä–µ–¥–Ω–µ–π —à–∫–æ–ª—ã',
        kk: '–û—Ä—Ç–∞ –º–µ–∫—Ç–µ–ø –º“±“ì–∞–ª—ñ–º—ñ',
      },
      description: {
        en: 'Educates students in various subjects at the secondary level',
        ru: '–û–±—É—á–∞–µ—Ç —Å—Ç—É–¥–µ–Ω—Ç–æ–≤ —Ä–∞–∑–ª–∏—á–Ω—ã–º –ø—Ä–µ–¥–º–µ—Ç–∞–º –Ω–∞ —Å—Ä–µ–¥–Ω–µ–º —É—Ä–æ–≤–Ω–µ',
        kk: '–û—Ä—Ç–∞ –¥–µ“£–≥–µ–π–¥–µ ”ô—Ä—Ç“Ø—Ä–ª—ñ –ø”ô–Ω–¥–µ—Ä –±–æ–π—ã–Ω—à–∞ –æ“õ—É—à—ã–ª–∞—Ä–¥—ã –æ“õ—ã—Ç–∞–¥—ã',
      },
      code: 'TE001',
      categoryId: createdIds.categories[4],
      featured: false,
    },
  ];

  for (const profession of professions) {
    try {
      const response = await api.post('/professions', profession);
      createdIds.professions.push(response.data.id);
      log(`‚úì Created profession: ${profession.name.en}`, colors.green);
    } catch (error: any) {
      log(`‚úó Failed to create profession: ${error.message}`, colors.red);
    }
  }
}

async function createArchetypeTypes() {
  log('\nüé≠ Creating Archetype Types (via Prisma)...', colors.cyan);

  const archetypeTypes = [
    {
      name: {
        en: 'Holland RIASEC',
        ru: 'RIASEC –•–æ–ª–ª–∞–Ω–¥–∞',
        kk: '–•–æ–ª–ª–∞–Ω–¥ RIASEC',
      },
      description: {
        en: 'Holland Occupational Themes: Realistic, Investigative, Artistic, Social, Enterprising, Conventional',
        ru: '–ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–µ —Ç–µ–º—ã –•–æ–ª–ª–∞–Ω–¥–∞: –†–µ–∞–ª–∏—Å—Ç–∏—á–Ω—ã–π, –ò—Å—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π, –ê—Ä—Ç–∏—Å—Ç–∏—á–Ω—ã–π, –°–æ—Ü–∏–∞–ª—å–Ω—ã–π, –ü—Ä–µ–¥–ø—Ä–∏–∏–º—á–∏–≤—ã–π, –ö–æ–Ω–≤–µ–Ω—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π',
        kk: '–•–æ–ª–ª–∞–Ω–¥ –∫”ô—Å—ñ–ø—Ç—ñ–∫ —Ç–∞“õ—ã—Ä—ã–ø—Ç–∞—Ä—ã: –®—ã–Ω–∞–π—ã, –ó–µ—Ä—Ç—Ç–µ—É—à—ñ–ª—ñ–∫, –ö”©—Ä–∫–µ–º–¥—ñ–∫, ”ò–ª–µ—É–º–µ—Ç—Ç—ñ–∫, –ö”ô—Å—ñ–ø–∫–µ—Ä–ª—ñ–∫, –î”ô—Å—Ç“Ø—Ä–ª—ñ',
      },
    },
    {
      name: {
        en: 'Big Five Personality',
        ru: '–ë–æ–ª—å—à–∞—è –ø—è—Ç–µ—Ä–∫–∞ –ª–∏—á–Ω–æ—Å—Ç–∏',
        kk: '–¢“±–ª“ì–∞–Ω—ã“£ “Æ–ª–∫–µ–Ω –ë–µ—Å—ñ',
      },
      description: {
        en: 'Five major personality traits: Openness, Conscientiousness, Extraversion, Agreeableness, Neuroticism',
        ru: '–ü—è—Ç—å –æ—Å–Ω–æ–≤–Ω—ã—Ö —á–µ—Ä—Ç –ª–∏—á–Ω–æ—Å—Ç–∏: –û—Ç–∫—Ä—ã—Ç–æ—Å—Ç—å, –î–æ–±—Ä–æ—Å–æ–≤–µ—Å—Ç–Ω–æ—Å—Ç—å, –≠–∫—Å—Ç—Ä–∞–≤–µ—Ä—Å–∏—è, –î–æ–±—Ä–æ–∂–µ–ª–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å, –ù–µ–π—Ä–æ—Ç–∏–∑–º',
        kk: '–ë–µ—Å –Ω–µ–≥—ñ–∑–≥—ñ —Ç“±–ª“ì–∞–ª—ã“õ “õ–∞—Å–∏–µ—Ç—Ç–µ—Ä: –ê—à—ã“õ—Ç—ã“õ, “∞“õ—ã–ø—Ç—ã–ª—ã“õ, –≠–∫—Å—Ç—Ä–∞–≤–µ—Ä—Å–∏—è, “∞–π—ã–º—à—ã–ª–¥—ã“õ, –ù–µ–≤—Ä–æ—Ç–∏–∑–º',
      },
    },
  ];

  for (const type of archetypeTypes) {
    try {
      const created = await prisma.archetypeType.create({ data: type });
      createdIds.archetypeTypes.push(created.id);
      log(`‚úì Created archetype type: ${type.name.en}`, colors.green);
    } catch (error: any) {
      log(`‚úó Failed to create archetype type: ${error.message}`, colors.red);
    }
  }
}

async function createArchetypes() {
  log('\nüé™ Creating Archetypes...', colors.cyan);

  const archetypes = [
    {
      name: {
        en: 'The Investigator',
        ru: '–ò—Å—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å',
        kk: '–ó–µ—Ä—Ç—Ç–µ—É—à—ñ',
      },
      archetypeTypeId: createdIds.archetypeTypes[0],
      description: {
        en: 'Analytical, intellectual, and methodical. Enjoys solving complex problems.',
        ru: '–ê–Ω–∞–ª–∏—Ç–∏—á–Ω—ã–π, –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π –∏ –º–µ—Ç–æ–¥–∏—á–Ω—ã–π. –õ—é–±–∏—Ç —Ä–µ—à–∞—Ç—å —Å–ª–æ–∂–Ω—ã–µ –∑–∞–¥–∞—á–∏.',
        kk: '–¢–∞–ª–¥–∞–º–∞–ª—ã, –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª–¥—ã –∂”ô–Ω–µ ”ô–¥—ñ—Å–Ω–∞–º–∞–ª—ã“õ. –ö“Ø—Ä–¥–µ–ª—ñ –º—ñ–Ω–¥–µ—Ç—Ç–µ—Ä–¥—ñ —à–µ—à—É–¥—ñ “±–Ω–∞—Ç–∞–¥—ã.',
      },
    },
    {
      name: {
        en: 'The Creator',
        ru: '–¢–≤–æ—Ä–µ—Ü',
        kk: '–ñ–∞—Ä–∞—Ç—É—à—ã',
      },
      archetypeTypeId: createdIds.archetypeTypes[0],
      description: {
        en: 'Imaginative, expressive, and original. Values creativity and innovation.',
        ru: '–¢–≤–æ—Ä—á–µ—Å–∫–∏–π, –≤—ã—Ä–∞–∑–∏—Ç–µ–ª—å–Ω—ã–π –∏ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π. –¶–µ–Ω–∏—Ç –∫—Ä–µ–∞—Ç–∏–≤–Ω–æ—Å—Ç—å –∏ –∏–Ω–Ω–æ–≤–∞—Ü–∏–∏.',
        kk: '“ö–∏—è–ª—à—ã–ª, –∫”©—Ä–Ω–µ–∫—Ç—ñ –∂”ô–Ω–µ —Ç“Ø–ø–Ω“±—Å“õ–∞–ª—ã“õ. –®—ã“ì–∞—Ä–º–∞—à—ã–ª—ã“õ –ø–µ–Ω –∏–Ω–Ω–æ–≤–∞—Ü–∏—è–Ω—ã –±–∞“ì–∞–ª–∞–π–¥—ã.',
      },
    },
    {
      name: {
        en: 'The Helper',
        ru: '–ü–æ–º–æ—â–Ω–∏–∫',
        kk: '–ö”©–º–µ–∫—à—ñ',
      },
      archetypeTypeId: createdIds.archetypeTypes[0],
      description: {
        en: 'Empathetic, supportive, and cooperative. Enjoys helping others.',
        ru: '–≠–º–ø–∞—Ç–∏—á–Ω—ã–π, –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—â–∏–π –∏ –∫–æ–æ–ø–µ—Ä–∞—Ç–∏–≤–Ω—ã–π. –õ—é–±–∏—Ç –ø–æ–º–æ–≥–∞—Ç—å –¥—Ä—É–≥–∏–º.',
        kk: '–≠–º–ø–∞—Ç–∏—è–ª—ã“õ, “õ–æ–ª–¥–∞—É—à—ã –∂”ô–Ω–µ —ã–Ω—Ç—ã–º–∞“õ—Ç–∞—Å—Ç—ã“õ. –ë–∞—Å“õ–∞–ª–∞—Ä“ì–∞ –∫”©–º–µ–∫—Ç–µ—Å—É–¥—ñ “±–Ω–∞—Ç–∞–¥—ã.',
      },
    },
    {
      name: {
        en: 'The Achiever',
        ru: '–î–æ—Å—Ç–∏–≥–∞—Ç–æ—Ä',
        kk: '–ñ–µ—Ç—ñ—Å—Ç—ñ–∫–∫–µ –∂–µ—Ç—É—à—ñ',
      },
      archetypeTypeId: createdIds.archetypeTypes[1],
      description: {
        en: 'Ambitious, organized, and goal-oriented. Strives for success.',
        ru: '–ê–º–±–∏—Ü–∏–æ–∑–Ω—ã–π, –æ—Ä–≥–∞–Ω–∏–∑–æ–≤–∞–Ω–Ω—ã–π –∏ —Ü–µ–ª–µ—É—Å—Ç—Ä–µ–º–ª–µ–Ω–Ω—ã–π. –°—Ç—Ä–µ–º–∏—Ç—Å—è –∫ —É—Å–ø–µ—Ö—É.',
        kk: '–ë–∏—ñ–∫ –º–∞“õ—Å–∞—Ç—Ç—ã, “±–π—ã–º–¥–∞—Å“õ–∞–Ω –∂”ô–Ω–µ –º–∞“õ—Å–∞—Ç“õ–∞ –±–∞“ì—ã—Ç—Ç–∞–ª“ì–∞–Ω. –¢–∞–±—ã—Å“õ–∞ “±–º—Ç—ã–ª–∞–¥—ã.',
      },
    },
    {
      name: {
        en: 'The Adventurer',
        ru: '–ò—Å–∫–∞—Ç–µ–ª—å –ø—Ä–∏–∫–ª—é—á–µ–Ω–∏–π',
        kk: '–®—ã—Ç—ã—Ä–º–∞–Ω —ñ–∑–¥–µ—É—à—ñ',
      },
      archetypeTypeId: createdIds.archetypeTypes[1],
      description: {
        en: 'Spontaneous, flexible, and experiences-seeking. Loves new challenges.',
        ru: '–°–ø–æ–Ω—Ç–∞–Ω–Ω—ã–π, –≥–∏–±–∫–∏–π –∏ –∏—â—É—â–∏–π –æ–ø—ã—Ç–∞. –õ—é–±–∏—Ç –Ω–æ–≤—ã–µ –≤—ã–∑–æ–≤—ã.',
        kk: '–ö–µ–Ω–µ—Ç—Ç–µ–Ω, –∏–∫–µ–º–¥—ñ –∂”ô–Ω–µ —Ç”ô–∂—ñ—Ä–∏–±–µ —ñ–∑–¥–µ–π—Ç—ñ–Ω. –ñ–∞“£–∞ —Å—ã–Ω-—Ç–µ–≥–µ—É—Ä—ñ–Ω–¥–µ—Ä–¥—ñ –∂–∞“õ—Å—ã –∫”©—Ä–µ–¥—ñ.',
      },
    },
  ];

  for (const archetype of archetypes) {
    try {
      const response = await api.post('/archetypes', archetype);
      createdIds.archetypes.push(response.data.id);
      log(`‚úì Created archetype: ${archetype.name.en}`, colors.green);
    } catch (error: any) {
      log(`‚úó Failed to create archetype: ${error.message}`, colors.red);
    }
  }
}

async function createQuizzes() {
  log('\nüìù Creating Quizzes...', colors.cyan);

  const quizzes = [
    {
      quizName: {
        en: 'Career Personality Assessment',
        ru: '–û—Ü–µ–Ω–∫–∞ –∫–∞—Ä—å–µ—Ä–Ω–æ–π –ª–∏—á–Ω–æ—Å—Ç–∏',
        kk: '–ú–∞–Ω—Å–∞–ø —Ç“±–ª“ì–∞—Å—ã–Ω –±–∞“ì–∞–ª–∞—É',
      },
      quizType: 'PERSONALITY',
      isFree: true,
      description: {
        en: 'Discover your career personality type based on Holland RIASEC model',
        ru: '–û—Ç–∫—Ä–æ–π—Ç–µ —Å–≤–æ–π —Ç–∏–ø –∫–∞—Ä—å–µ—Ä–Ω–æ–π –ª–∏—á–Ω–æ—Å—Ç–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –º–æ–¥–µ–ª–∏ RIASEC –•–æ–ª–ª–∞–Ω–¥–∞',
        kk: '–•–æ–ª–ª–∞–Ω–¥ RIASEC “Ø–ª–≥—ñ—Å—ñ –Ω–µ–≥—ñ–∑—ñ–Ω–¥–µ –º–∞–Ω—Å–∞–ø —Ç“±–ª“ì–∞—Å—ã–Ω—ã“£ —Ç“Ø—Ä—ñ–Ω —Ç–∞–±—ã“£—ã–∑',
      },
    },
    {
      quizName: {
        en: 'Aptitude Test for IT Careers',
        ru: '–¢–µ—Å—Ç —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π –¥–ª—è IT –∫–∞—Ä—å–µ—Ä—ã',
        kk: 'IT –º–∞–Ω—Å–∞–ø—Ç–∞—Ä“ì–∞ “õ–∞–±—ñ–ª–µ—Ç—Ç—ñ–ª—ñ–∫ —Ç–µ—Å—Ç—ñ',
      },
      quizType: 'APTITUDE',
      isFree: false,
      description: {
        en: 'Assess your aptitude for various IT and technology careers',
        ru: '–û—Ü–µ–Ω–∏—Ç–µ —Å–≤–æ–∏ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ –∫ —Ä–∞–∑–ª–∏—á–Ω—ã–º IT –∏ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–º –∫–∞—Ä—å–µ—Ä–∞–º',
        kk: '”ò—Ä—Ç“Ø—Ä–ª—ñ IT –∂”ô–Ω–µ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—è–ª—ã“õ –º–∞–Ω—Å–∞–ø—Ç–∞—Ä“ì–∞ “õ–∞–±—ñ–ª–µ—Ç—Ç—ñ–ª—ñ–∫—Ç–µ—Ä—ñ“£—ñ–∑–¥—ñ –±–∞“ì–∞–ª–∞“£—ã–∑',
      },
    },
    {
      quizName: {
        en: 'Medical Career Knowledge Quiz',
        ru: '–ö–≤–∏–∑ –∑–Ω–∞–Ω–∏–π –º–µ–¥–∏—Ü–∏–Ω—Å–∫–æ–π –∫–∞—Ä—å–µ—Ä—ã',
        kk: '–ú–µ–¥–∏—Ü–∏–Ω–∞–ª—ã“õ –º–∞–Ω—Å–∞–ø –±—ñ–ª—ñ–º—ñ —Å“±—Ä–∞“õ—Ç–∞—Ä—ã',
      },
      quizType: 'KNOWLEDGE',
      isFree: true,
      description: {
        en: 'Test your knowledge about medical professions and healthcare',
        ru: '–ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å–≤–æ–∏ –∑–Ω–∞–Ω–∏—è –æ –º–µ–¥–∏—Ü–∏–Ω—Å–∫–∏—Ö –ø—Ä–æ—Ñ–µ—Å—Å–∏—è—Ö –∏ –∑–¥—Ä–∞–≤–æ–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏',
        kk: '–ú–µ–¥–∏—Ü–∏–Ω–∞–ª—ã“õ –º–∞–º–∞–Ω–¥—ã“õ—Ç–∞—Ä –º–µ–Ω –¥–µ–Ω—Å–∞—É–ª—ã“õ —Å–∞“õ—Ç–∞—É —Ç—É—Ä–∞–ª—ã –±—ñ–ª—ñ–º–¥–µ—Ä—ñ“£—ñ–∑–¥—ñ —Ç–µ–∫—Å–µ—Ä—ñ“£—ñ–∑',
      },
    },
    {
      quizName: {
        en: 'Business Career Navigator',
        ru: '–ù–∞–≤–∏–≥–∞—Ç–æ—Ä –±–∏–∑–Ω–µ—Å-–∫–∞—Ä—å–µ—Ä—ã',
        kk: '–ë–∏–∑–Ω–µ—Å –º–∞–Ω—Å–∞–ø –Ω–∞–≤–∏–≥–∞—Ç–æ—Ä—ã',
      },
      quizType: 'CAREER',
      isFree: false,
      description: {
        en: 'Find the best business career path based on your skills and interests',
        ru: '–ù–∞–π–¥–∏—Ç–µ –ª—É—á—à–∏–π –ø—É—Ç—å –±–∏–∑–Ω–µ—Å-–∫–∞—Ä—å–µ—Ä—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤–∞—à–∏—Ö –Ω–∞–≤—ã–∫–æ–≤ –∏ –∏–Ω—Ç–µ—Ä–µ—Å–æ–≤',
        kk: '–î–∞“ì–¥—ã–ª–∞—Ä –º–µ–Ω “õ—ã–∑—ã“ì—É—à—ã–ª—ã“õ—Ç–∞—Ä –Ω–µ–≥—ñ–∑—ñ–Ω–¥–µ –µ“£ –∂–∞“õ—Å—ã –±–∏–∑–Ω–µ—Å –º–∞–Ω—Å–∞–ø –∂–æ–ª—ã–Ω —Ç–∞–±—ã“£—ã–∑',
      },
    },
  ];

  for (const quiz of quizzes) {
    try {
      const response = await api.post('/quizzes', quiz);
      createdIds.quizzes.push(response.data.id);
      log(`‚úì Created quiz: ${quiz.quizName.en}`, colors.green);
    } catch (error: any) {
      log(`‚úó Failed to create quiz: ${error.message}`, colors.red);
    }
  }
}

async function createOrganizations() {
  log('\nüè¢ Creating Organizations (via Prisma)...', colors.cyan);

  const organizations = [
    {
      name: 'Nazarbayev Intellectual School of Almaty',
      regionId: createdIds.regions[2], // Almaty City
      type: OrganizationType.SCHOOL,
    },
    {
      name: 'BIL School Astana',
      regionId: createdIds.regions[1], // Astana City
      type: OrganizationType.SCHOOL,
    },
    {
      name: 'Al-Farabi Kazakh National University',
      regionId: createdIds.regions[2], // Almaty City
      type: OrganizationType.UNIVERSITY,
    },
    {
      name: 'KIMEP University',
      regionId: createdIds.regions[2], // Almaty City
      type: OrganizationType.UNIVERSITY,
    },
    {
      name: 'Astana IT College',
      regionId: createdIds.regions[1], // Astana City
      type: OrganizationType.COLLEGE,
    },
  ];

  for (const org of organizations) {
    try {
      const created = await prisma.organization.create({ data: org });
      createdIds.organizations.push(created.id);
      log(`‚úì Created organization: ${org.name}`, colors.green);
    } catch (error: any) {
      log(`‚úó Failed to create organization: ${error.message}`, colors.red);
    }
  }
}

async function createLicenseClasses() {
  log('\nüé´ Creating License Classes (via Prisma)...', colors.cyan);

  const licenseClasses = [
    { name: 'Premium School License' },
    { name: 'Standard School License' },
    { name: 'University Research License' },
    { name: 'College Basic License' },
  ];

  for (const licenseClass of licenseClasses) {
    try {
      const created = await prisma.licenseClass.create({ data: licenseClass });
      createdIds.licenseClasses.push(created.id);
      log(`‚úì Created license class: ${licenseClass.name}`, colors.green);
    } catch (error: any) {
      log(`‚úó Failed to create license class: ${error.message}`, colors.red);
    }
  }
}

async function createLicenses() {
  log('\nüìú Creating Licenses (via Prisma)...', colors.cyan);

  const licenses = [
    {
      name: 'NIS Almaty Premium License',
      licenseCode: 'LIC-NIS-ALM-001',
      startDate: new Date('2025-01-01'),
      expireDate: new Date('2025-12-31'),
      licenseClassId: createdIds.licenseClasses[0],
      organizationId: createdIds.organizations[0],
    },
    {
      name: 'BIL Astana Standard License',
      licenseCode: 'LIC-BIL-AST-001',
      startDate: new Date('2025-01-01'),
      expireDate: new Date('2025-06-30'),
      licenseClassId: createdIds.licenseClasses[1],
      organizationId: createdIds.organizations[1],
    },
    {
      name: 'KazNU Research License',
      licenseCode: 'LIC-KAZNU-ALM-001',
      startDate: new Date('2025-01-01'),
      expireDate: new Date('2026-12-31'),
      licenseClassId: createdIds.licenseClasses[2],
      organizationId: createdIds.organizations[2],
    },
  ];

  for (const license of licenses) {
    try {
      const created = await prisma.license.create({ data: license });
      createdIds.licenses.push(created.id);
      log(`‚úì Created license: ${license.name}`, colors.green);
    } catch (error: any) {
      log(`‚úó Failed to create license: ${error.message}`, colors.red);
    }
  }
}

async function createQuestions() {
  log('\n‚ùì Creating Questions (via Prisma)...', colors.cyan);

  const questions = [
    // Questions for Career Personality Assessment
    {
      quizId: createdIds.quizzes[0],
      questionType: QuestionType.SCALE,
      questionText: {
        en: 'I enjoy working with tools and machinery',
        ru: '–ú–Ω–µ –Ω—Ä–∞–≤–∏—Ç—Å—è —Ä–∞–±–æ—Ç–∞—Ç—å —Å –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞–º–∏ –∏ –º–µ—Ö–∞–Ω–∏–∑–º–∞–º–∏',
        kk: '–ú–∞“ì–∞–Ω “õ“±—Ä–∞–ª–¥–∞—Ä –º–µ–Ω –º–µ—Ö–∞–Ω–∏–∑–º–¥–µ—Ä–º–µ–Ω –∂“±–º—ã—Å —ñ—Å—Ç–µ—É “±–Ω–∞–π–¥—ã',
      },
      answers: {
        scale: { min: 1, max: 5, labels: { en: ['Strongly Disagree', 'Disagree', 'Neutral', 'Agree', 'Strongly Agree'], ru: ['–ö–∞—Ç–µ–≥–æ—Ä–∏—á–µ—Å–∫–∏ –Ω–µ —Å–æ–≥–ª–∞—Å–µ–Ω', '–ù–µ —Å–æ–≥–ª–∞—Å–µ–Ω', '–ù–µ–π—Ç—Ä–∞–ª—å–Ω–æ', '–°–æ–≥–ª–∞—Å–µ–Ω', '–ü–æ–ª–Ω–æ—Å—Ç—å—é —Å–æ–≥–ª–∞—Å–µ–Ω'], kk: ['“ö–∞—Ç–∞“£ –∫–µ–ª—ñ—Å–ø–µ–π–º—ñ–Ω', '–ö–µ–ª—ñ—Å–ø–µ–π–º—ñ–Ω', '–ë–µ–π—Ç–∞—Ä–∞–ø', '–ö–µ–ª—ñ—Å–µ–º—ñ–Ω', '–¢–æ–ª—ã“õ –∫–µ–ª—ñ—Å–µ–º—ñ–Ω'] } },
      },
      parameters: { archetype: 'realistic', weight: 1 },
    },
    {
      quizId: createdIds.quizzes[0],
      questionType: QuestionType.SCALE,
      questionText: {
        en: 'I prefer working with data and solving complex problems',
        ru: '–Ø –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞—é —Ä–∞–±–æ—Ç–∞—Ç—å —Å –¥–∞–Ω–Ω—ã–º–∏ –∏ —Ä–µ—à–∞—Ç—å —Å–ª–æ–∂–Ω—ã–µ –∑–∞–¥–∞—á–∏',
        kk: '–ú–µ–Ω –¥–µ—Ä–µ–∫—Ç–µ—Ä–º–µ–Ω –∂“±–º—ã—Å —ñ—Å—Ç–µ—É–¥—ñ –∂”ô–Ω–µ –∫“Ø—Ä–¥–µ–ª—ñ –º—ñ–Ω–¥–µ—Ç—Ç–µ—Ä–¥—ñ —à–µ—à—É–¥—ñ “±–Ω–∞—Ç–∞–º—ã–Ω',
      },
      answers: {
        scale: { min: 1, max: 5, labels: { en: ['Strongly Disagree', 'Disagree', 'Neutral', 'Agree', 'Strongly Agree'], ru: ['–ö–∞—Ç–µ–≥–æ—Ä–∏—á–µ—Å–∫–∏ –Ω–µ —Å–æ–≥–ª–∞—Å–µ–Ω', '–ù–µ —Å–æ–≥–ª–∞—Å–µ–Ω', '–ù–µ–π—Ç—Ä–∞–ª—å–Ω–æ', '–°–æ–≥–ª–∞—Å–µ–Ω', '–ü–æ–ª–Ω–æ—Å—Ç—å—é —Å–æ–≥–ª–∞—Å–µ–Ω'], kk: ['“ö–∞—Ç–∞“£ –∫–µ–ª—ñ—Å–ø–µ–π–º—ñ–Ω', '–ö–µ–ª—ñ—Å–ø–µ–π–º—ñ–Ω', '–ë–µ–π—Ç–∞—Ä–∞–ø', '–ö–µ–ª—ñ—Å–µ–º—ñ–Ω', '–¢–æ–ª—ã“õ –∫–µ–ª—ñ—Å–µ–º—ñ–Ω'] } },
      },
      parameters: { archetype: 'investigative', weight: 1 },
    },
    {
      quizId: createdIds.quizzes[0],
      questionType: QuestionType.SCALE,
      questionText: {
        en: 'I express myself through creative activities',
        ru: '–Ø –≤—ã—Ä–∞–∂–∞—é —Å–µ–±—è —á–µ—Ä–µ–∑ —Ç–≤–æ—Ä—á–µ—Å–∫—É—é –¥–µ—è—Ç–µ–ª—å–Ω–æ—Å—Ç—å',
        kk: '–ú–µ–Ω ”©–∑—ñ–º–¥—ñ —à—ã“ì–∞—Ä–º–∞—à—ã–ª—ã“õ —ñ—Å-”ô—Ä–µ–∫–µ—Ç –∞—Ä“õ—ã–ª—ã –∫”©—Ä—Å–µ—Ç–µ–º—ñ–Ω',
      },
      answers: {
        scale: { min: 1, max: 5, labels: { en: ['Strongly Disagree', 'Disagree', 'Neutral', 'Agree', 'Strongly Agree'], ru: ['–ö–∞—Ç–µ–≥–æ—Ä–∏—á–µ—Å–∫–∏ –Ω–µ —Å–æ–≥–ª–∞—Å–µ–Ω', '–ù–µ —Å–æ–≥–ª–∞—Å–µ–Ω', '–ù–µ–π—Ç—Ä–∞–ª—å–Ω–æ', '–°–æ–≥–ª–∞—Å–µ–Ω', '–ü–æ–ª–Ω–æ—Å—Ç—å—é —Å–æ–≥–ª–∞—Å–µ–Ω'], kk: ['“ö–∞—Ç–∞“£ –∫–µ–ª—ñ—Å–ø–µ–π–º—ñ–Ω', '–ö–µ–ª—ñ—Å–ø–µ–π–º—ñ–Ω', '–ë–µ–π—Ç–∞—Ä–∞–ø', '–ö–µ–ª—ñ—Å–µ–º—ñ–Ω', '–¢–æ–ª—ã“õ –∫–µ–ª—ñ—Å–µ–º—ñ–Ω'] } },
      },
      parameters: { archetype: 'artistic', weight: 1 },
    },
    // Questions for IT Aptitude Test
    {
      quizId: createdIds.quizzes[1],
      questionType: QuestionType.MULTIPLE_CHOICE,
      questionText: {
        en: 'What is the time complexity of binary search?',
        ru: '–ö–∞–∫–æ–≤–∞ –≤—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å –±–∏–Ω–∞—Ä–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞?',
        kk: '–ï–∫—ñ–ª—ñ–∫ —ñ–∑–¥–µ—É–¥—ñ“£ —É–∞“õ—ã—Ç—Ç—ã“õ –∫“Ø—Ä–¥–µ–ª—ñ–ª—ñ–≥—ñ “õ–∞–Ω–¥–∞–π?',
      },
      answers: {
        options: [
          { id: 'a', text: { en: 'O(n)', ru: 'O(n)', kk: 'O(n)' }, isCorrect: false },
          { id: 'b', text: { en: 'O(log n)', ru: 'O(log n)', kk: 'O(log n)' }, isCorrect: true },
          { id: 'c', text: { en: 'O(n¬≤)', ru: 'O(n¬≤)', kk: 'O(n¬≤)' }, isCorrect: false },
          { id: 'd', text: { en: 'O(1)', ru: 'O(1)', kk: 'O(1)' }, isCorrect: false },
        ],
      },
      parameters: { topic: 'algorithms', difficulty: 'medium' },
    },
    {
      quizId: createdIds.quizzes[1],
      questionType: QuestionType.MULTIPLE_CHOICE,
      questionText: {
        en: 'Which programming paradigm focuses on immutability?',
        ru: '–ö–∞–∫–∞—è –ø–∞—Ä–∞–¥–∏–≥–º–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è —Ñ–æ–∫—É—Å–∏—Ä—É–µ—Ç—Å—è –Ω–∞ –Ω–µ–∏–∑–º–µ–Ω–Ω–æ—Å—Ç–∏?',
        kk: '“ö–∞–π –±–∞“ì–¥–∞—Ä–ª–∞–º–∞–ª–∞—É –ø–∞—Ä–∞–¥–∏–≥–º–∞—Å—ã ”©–∑–≥–µ—Ä–º–µ–π—Ç—ñ–Ω–¥—ñ–∫–∫–µ –Ω–∞–∑–∞—Ä –∞—É–¥–∞—Ä–∞–¥—ã?',
      },
      answers: {
        options: [
          { id: 'a', text: { en: 'Object-Oriented', ru: '–û–±—ä–µ–∫—Ç–Ω–æ-–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ', kk: '–û–±—ä–µ–∫—Ç—ñ–≥–µ –±–∞“ì—ã—Ç—Ç–∞–ª“ì–∞–Ω' }, isCorrect: false },
          { id: 'b', text: { en: 'Functional', ru: '–§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–µ', kk: '–§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª–¥—ã“õ' }, isCorrect: true },
          { id: 'c', text: { en: 'Procedural', ru: '–ü—Ä–æ—Ü–µ–¥—É—Ä–Ω–æ–µ', kk: '–ü—Ä–æ—Ü–µ–¥—É—Ä–∞–ª—ã“õ' }, isCorrect: false },
          { id: 'd', text: { en: 'Logic', ru: '–õ–æ–≥–∏—á–µ—Å–∫–æ–µ', kk: '–õ–æ–≥–∏–∫–∞–ª—ã“õ' }, isCorrect: false },
        ],
      },
      parameters: { topic: 'programming_paradigms', difficulty: 'easy' },
    },
    // Questions for Medical Knowledge Quiz
    {
      quizId: createdIds.quizzes[2],
      questionType: QuestionType.TRUE_FALSE,
      questionText: {
        en: 'The human heart has four chambers',
        ru: '–ß–µ–ª–æ–≤–µ—á–µ—Å–∫–æ–µ —Å–µ—Ä–¥—Ü–µ –∏–º–µ–µ—Ç —á–µ—Ç—ã—Ä–µ –∫–∞–º–µ—Ä—ã',
        kk: '–ê–¥–∞–º –∂“Ø—Ä–µ–≥—ñ–Ω–¥–µ —Ç”©—Ä—Ç –∫–∞–º–µ—Ä–∞ –±–∞—Ä',
      },
      answers: {
        correctAnswer: true,
      },
      parameters: { topic: 'anatomy', difficulty: 'easy' },
    },
  ];

  for (const question of questions) {
    try {
      const created = await prisma.question.create({ data: question });
      createdIds.questions.push(created.id);
      log(`‚úì Created question for quiz`, colors.green);
    } catch (error: any) {
      log(`‚úó Failed to create question: ${error.message}`, colors.red);
    }
  }
}

async function createSpecs() {
  log('\nüìö Creating Specs (via Prisma)...', colors.cyan);

  const specs = [
    {
      name: {
        en: 'Computer Science',
        ru: '–ö–æ–º–ø—å—é—Ç–µ—Ä–Ω—ã–µ –Ω–∞—É–∫–∏',
        kk: '–ö–æ–º–ø—å—é—Ç–µ—Ä–ª—ñ–∫ “ì—ã–ª—ã–º–¥–∞—Ä',
      },
      code: 'SPEC-CS-001',
      description: {
        en: 'Study of computation, algorithms, and information processing',
        ru: '–ò–∑—É—á–µ–Ω–∏–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏–π, –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ –∏ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏',
        kk: '–ï—Å–µ–ø—Ç–µ—É–ª–µ—Ä–¥—ñ, –∞–ª–≥–æ—Ä–∏—Ç–º–¥–µ—Ä–¥—ñ –∂”ô–Ω–µ –∞“õ–ø–∞—Ä–∞—Ç—Ç—ã ”©“£–¥–µ—É–¥—ñ –∑–µ—Ä—Ç—Ç–µ—É',
      },
      subjects: {
        en: ['Mathematics', 'Physics', 'Informatics'],
        ru: ['–ú–∞—Ç–µ–º–∞—Ç–∏–∫–∞', '–§–∏–∑–∏–∫–∞', '–ò–Ω—Ñ–æ—Ä–º–∞—Ç–∏–∫–∞'],
        kk: ['–ú–∞—Ç–µ–º–∞—Ç–∏–∫–∞', '–§–∏–∑–∏–∫–∞', '–ò–Ω—Ñ–æ—Ä–º–∞—Ç–∏–∫–∞'],
      },
      groupName: {
        en: 'Engineering and Technology',
        ru: '–ò–Ω–∂–µ–Ω–µ—Ä–∏—è –∏ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–∏',
        kk: '–ò–Ω–∂–µ–Ω–µ—Ä–∏—è –∂”ô–Ω–µ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—è–ª–∞—Ä',
      },
    },
    {
      name: {
        en: 'General Medicine',
        ru: '–û–±—â–∞—è –º–µ–¥–∏—Ü–∏–Ω–∞',
        kk: '–ñ–∞–ª–ø—ã –º–µ–¥–∏—Ü–∏–Ω–∞',
      },
      code: 'SPEC-MED-001',
      description: {
        en: 'Comprehensive medical education for future doctors',
        ru: '–ö–æ–º–ø–ª–µ–∫—Å–Ω–æ–µ –º–µ–¥–∏—Ü–∏–Ω—Å–∫–æ–µ –æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –¥–ª—è –±—É–¥—É—â–∏—Ö –≤—Ä–∞—á–µ–π',
        kk: '–ë–æ–ª–∞—à–∞“õ –¥”ô—Ä—ñ–≥–µ—Ä–ª–µ—Ä–≥–µ –∞—Ä–Ω–∞–ª“ì–∞–Ω –∫–µ—à–µ–Ω–¥—ñ –º–µ–¥–∏—Ü–∏–Ω–∞–ª—ã“õ –±—ñ–ª—ñ–º',
      },
      subjects: {
        en: ['Biology', 'Chemistry', 'Physics'],
        ru: ['–ë–∏–æ–ª–æ–≥–∏—è', '–•–∏–º–∏—è', '–§–∏–∑–∏–∫–∞'],
        kk: ['–ë–∏–æ–ª–æ–≥–∏—è', '–•–∏–º–∏—è', '–§–∏–∑–∏–∫–∞'],
      },
      groupName: {
        en: 'Healthcare',
        ru: '–ó–¥—Ä–∞–≤–æ–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ',
        kk: '–î–µ–Ω—Å–∞—É–ª—ã“õ —Å–∞“õ—Ç–∞—É',
      },
    },
    {
      name: {
        en: 'Finance',
        ru: '–§–∏–Ω–∞–Ω—Å—ã',
        kk: '“ö–∞—Ä–∂—ã',
      },
      code: 'SPEC-FIN-001',
      description: {
        en: 'Study of financial systems, markets, and investment',
        ru: '–ò–∑—É—á–µ–Ω–∏–µ —Ñ–∏–Ω–∞–Ω—Å–æ–≤—ã—Ö —Å–∏—Å—Ç–µ–º, —Ä—ã–Ω–∫–æ–≤ –∏ –∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–π',
        kk: '“ö–∞—Ä–∂—ã –∂“Ø–π–µ–ª–µ—Ä—ñ–Ω, –Ω–∞—Ä—ã“õ—Ç–∞—Ä–¥—ã –∂”ô–Ω–µ –∏–Ω–≤–µ—Å—Ç–∏—Ü–∏—è–ª–∞—Ä–¥—ã –∑–µ—Ä—Ç—Ç–µ—É',
      },
      subjects: {
        en: ['Mathematics', 'Economics', 'History'],
        ru: ['–ú–∞—Ç–µ–º–∞—Ç–∏–∫–∞', '–≠–∫–æ–Ω–æ–º–∏–∫–∞', '–ò—Å—Ç–æ—Ä–∏—è'],
        kk: ['–ú–∞—Ç–µ–º–∞—Ç–∏–∫–∞', '–≠–∫–æ–Ω–æ–º–∏–∫–∞', '–¢–∞—Ä–∏—Ö'],
      },
      groupName: {
        en: 'Business and Economics',
        ru: '–ë–∏–∑–Ω–µ—Å –∏ —ç–∫–æ–Ω–æ–º–∏–∫–∞',
        kk: '–ë–∏–∑–Ω–µ—Å –∂”ô–Ω–µ —ç–∫–æ–Ω–æ–º–∏–∫–∞',
      },
    },
    {
      name: {
        en: 'Graphic Design',
        ru: '–ì—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–π –¥–∏–∑–∞–π–Ω',
        kk: '–ì—Ä–∞—Ñ–∏–∫–∞–ª—ã“õ –¥–∏–∑–∞–π–Ω',
      },
      code: 'SPEC-GD-001',
      description: {
        en: 'Visual communication through graphic design principles',
        ru: '–í–∏–∑—É–∞–ª—å–Ω–∞—è –∫–æ–º–º—É–Ω–∏–∫–∞—Ü–∏—è —á–µ—Ä–µ–∑ –ø—Ä–∏–Ω—Ü–∏–ø—ã –≥—Ä–∞—Ñ–∏—á–µ—Å–∫–æ–≥–æ –¥–∏–∑–∞–π–Ω–∞',
        kk: '–ì—Ä–∞—Ñ–∏–∫–∞–ª—ã“õ –¥–∏–∑–∞–π–Ω “õ–∞“ì–∏–¥–∞–ª–∞—Ä—ã –∞—Ä“õ—ã–ª—ã –≤–∏–∑—É–∞–ª–¥—ã “õ–∞—Ä—ã–º-“õ–∞—Ç—ã–Ω–∞—Å',
      },
      subjects: {
        en: ['Creative Exam', 'Drawing', 'History'],
        ru: ['–¢–≤–æ—Ä—á–µ—Å–∫–∏–π —ç–∫–∑–∞–º–µ–Ω', '–†–∏—Å—É–Ω–æ–∫', '–ò—Å—Ç–æ—Ä–∏—è'],
        kk: ['–®—ã“ì–∞—Ä–º–∞—à—ã–ª—ã“õ –µ–º—Ç–∏—Ö–∞–Ω', '–°—É—Ä–µ—Ç —Å–∞–ª—É', '–¢–∞—Ä–∏—Ö'],
      },
      groupName: {
        en: 'Arts and Design',
        ru: '–ò—Å–∫—É—Å—Å—Ç–≤–æ –∏ –¥–∏–∑–∞–π–Ω',
        kk: '”®–Ω–µ—Ä –∂”ô–Ω–µ –¥–∏–∑–∞–π–Ω',
      },
    },
  ];

  for (const spec of specs) {
    try {
      const created = await prisma.spec.create({ data: spec });
      createdIds.specs.push(created.id);
      log(`‚úì Created spec: ${spec.name.en}`, colors.green);
    } catch (error: any) {
      log(`‚úó Failed to create spec: ${error.message}`, colors.red);
    }
  }
}

async function createUniversities() {
  log('\nüéì Creating Universities (via Prisma)...', colors.cyan);

  const universities = [
    {
      name: {
        en: 'Al-Farabi Kazakh National University',
        ru: '–ö–∞–∑–∞—Ö—Å–∫–∏–π –Ω–∞—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π —É–Ω–∏–≤–µ—Ä—Å–∏—Ç–µ—Ç –∏–º–µ–Ω–∏ –∞–ª—å-–§–∞—Ä–∞–±–∏',
        kk: '”ò–ª-–§–∞—Ä–∞–±–∏ –∞—Ç—ã–Ω–¥–∞“ì—ã “ö–∞–∑–∞“õ “±–ª—Ç—Ç—ã“õ —É–Ω–∏–≤–µ—Ä—Å–∏—Ç–µ—Ç—ñ',
      },
      code: 'UNI-KAZNU-001',
      description: {
        en: 'Leading national university in Kazakhstan',
        ru: '–í–µ–¥—É—â–∏–π –Ω–∞—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π —É–Ω–∏–≤–µ—Ä—Å–∏—Ç–µ—Ç –ö–∞–∑–∞—Ö—Å—Ç–∞–Ω–∞',
        kk: '“ö–∞–∑–∞“õ—Å—Ç–∞–Ω–¥–∞“ì—ã –∂–µ—Ç–µ–∫—à—ñ “±–ª—Ç—Ç—ã“õ —É–Ω–∏–≤–µ—Ä—Å–∏—Ç–µ—Ç',
      },
    },
    {
      name: {
        en: 'KIMEP University',
        ru: '–£–Ω–∏–≤–µ—Ä—Å–∏—Ç–µ—Ç –ö–ò–ú–≠–ü',
        kk: '–ö–ò–ú–≠–ü —É–Ω–∏–≤–µ—Ä—Å–∏—Ç–µ—Ç—ñ',
      },
      code: 'UNI-KIMEP-001',
      description: {
        en: 'Kazakhstan Institute of Management, Economics and Strategic Research',
        ru: '–ö–∞–∑–∞—Ö—Å—Ç–∞–Ω—Å–∫–∏–π –∏–Ω—Å—Ç–∏—Ç—É—Ç –º–µ–Ω–µ–¥–∂–º–µ–Ω—Ç–∞, —ç–∫–æ–Ω–æ–º–∏–∫–∏ –∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–∏—Ö –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–π',
        kk: '“ö–∞–∑–∞“õ—Å—Ç–∞–Ω –º–µ–Ω–µ–¥–∂–º–µ–Ω—Ç, —ç–∫–æ–Ω–æ–º–∏–∫–∞ –∂”ô–Ω–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏—è–ª—ã“õ –∑–µ—Ä—Ç—Ç–µ—É–ª–µ—Ä –∏–Ω—Å—Ç–∏—Ç—É—Ç—ã',
      },
    },
    {
      name: {
        en: 'Nazarbayev University',
        ru: '–ù–∞–∑–∞—Ä–±–∞–µ–≤ –£–Ω–∏–≤–µ—Ä—Å–∏—Ç–µ—Ç',
        kk: '–ù–∞–∑–∞—Ä–±–∞–µ–≤ –£–Ω–∏–≤–µ—Ä—Å–∏—Ç–µ—Ç—ñ',
      },
      code: 'UNI-NU-001',
      description: {
        en: 'Autonomous research university in Astana',
        ru: '–ê–≤—Ç–æ–Ω–æ–º–Ω—ã–π –∏—Å—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π —É–Ω–∏–≤–µ—Ä—Å–∏—Ç–µ—Ç –≤ –ê—Å—Ç–∞–Ω–µ',
        kk: '–ê—Å—Ç–∞–Ω–∞–¥–∞“ì—ã –∞–≤—Ç–æ–Ω–æ–º–¥—ã –∑–µ—Ä—Ç—Ç–µ—É —É–Ω–∏–≤–µ—Ä—Å–∏—Ç–µ—Ç—ñ',
      },
    },
  ];

  for (const university of universities) {
    try {
      const created = await prisma.university.create({ data: university });
      createdIds.universities.push(created.id);
      log(`‚úì Created university: ${university.name.en}`, colors.green);
    } catch (error: any) {
      log(`‚úó Failed to create university: ${error.message}`, colors.red);
    }
  }
}

async function createTestScoreTypes() {
  log('\nüìä Creating Test Score Types (via Prisma)...', colors.cyan);

  const testScoreTypes = [
    {
      name: 'UNT (Unified National Testing)',
      parameters: {
        subjects: ['Mathematics', 'Reading Literacy', 'History of Kazakhstan'],
        maxScore: 140,
      },
    },
    {
      name: 'Creative Exam',
      parameters: {
        subjects: ['Drawing', 'Composition', 'Portfolio Review'],
        maxScore: 100,
      },
    },
  ];

  for (const type of testScoreTypes) {
    try {
      const created = await prisma.testScoreType.create({ data: type });
      createdIds.testScoreTypes.push(created.id);
      log(`‚úì Created test score type: ${type.name}`, colors.green);
    } catch (error: any) {
      log(`‚úó Failed to create test score type: ${error.message}`, colors.red);
    }
  }
}

async function createRelationships() {
  log('\nüîó Creating Relationship Data (via Prisma)...', colors.cyan);

  // SpecUniversities
  const specUniversities = [
    { specId: createdIds.specs[0], universityId: createdIds.universities[0], isEnglish: false },
    { specId: createdIds.specs[0], universityId: createdIds.universities[2], isEnglish: true },
    { specId: createdIds.specs[1], universityId: createdIds.universities[0], isEnglish: false },
    { specId: createdIds.specs[2], universityId: createdIds.universities[1], isEnglish: true },
    { specId: createdIds.specs[3], universityId: createdIds.universities[0], isEnglish: false },
  ];

  const specUniversityIds: string[] = [];
  for (const su of specUniversities) {
    try {
      const created = await prisma.specUniversity.create({ data: su });
      specUniversityIds.push(created.id);
      log(`‚úì Linked spec to university`, colors.green);
    } catch (error: any) {
      log(`‚úó Failed to link spec to university: ${error.message}`, colors.red);
    }
  }

  // ProfessionSpecs
  const professionSpecs = [
    { professionId: createdIds.professions[0], specId: createdIds.specs[0] }, // Software Engineer -> CS
    { professionId: createdIds.professions[1], specId: createdIds.specs[0] }, // Data Scientist -> CS
    { professionId: createdIds.professions[2], specId: createdIds.specs[1] }, // Medical Doctor -> General Medicine
    { professionId: createdIds.professions[3], specId: createdIds.specs[2] }, // Financial Analyst -> Finance
    { professionId: createdIds.professions[4], specId: createdIds.specs[3] }, // Graphic Designer -> Graphic Design
  ];

  for (const ps of professionSpecs) {
    try {
      await prisma.professionSpec.create({ data: ps });
      log(`‚úì Linked profession to spec`, colors.green);
    } catch (error: any) {
      log(`‚úó Failed to link profession to spec: ${error.message}`, colors.red);
    }
  }

  // ProfessionArchetypes
  const professionArchetypes = [
    { professionId: createdIds.professions[0], archetypeId: createdIds.archetypes[0], score: 85 }, // Software Engineer -> Investigator
    { professionId: createdIds.professions[0], archetypeId: createdIds.archetypes[1], score: 60 }, // Software Engineer -> Creator
    { professionId: createdIds.professions[1], archetypeId: createdIds.archetypes[0], score: 90 }, // Data Scientist -> Investigator
    { professionId: createdIds.professions[2], archetypeId: createdIds.archetypes[2], score: 80 }, // Medical Doctor -> Helper
    { professionId: createdIds.professions[3], archetypeId: createdIds.archetypes[3], score: 75 }, // Financial Analyst -> Achiever
    { professionId: createdIds.professions[4], archetypeId: createdIds.archetypes[1], score: 95 }, // Graphic Designer -> Creator
  ];

  for (const pa of professionArchetypes) {
    try {
      await prisma.professionArchetype.create({ data: pa });
      log(`‚úì Linked profession to archetype with score`, colors.green);
    } catch (error: any) {
      log(`‚úó Failed to link profession to archetype: ${error.message}`, colors.red);
    }
  }

  // TestScores
  const testScores = [
    {
      year: 2025,
      specUniversityId: specUniversityIds[0],
      minPoints: 110,
      maxPoints: 140,
      grantCounts: 50,
      typeId: createdIds.testScoreTypes[0],
    },
    {
      year: 2025,
      specUniversityId: specUniversityIds[1],
      minPoints: 120,
      maxPoints: 140,
      grantCounts: 30,
      typeId: createdIds.testScoreTypes[0],
    },
    {
      year: 2025,
      specUniversityId: specUniversityIds[2],
      minPoints: 115,
      maxPoints: 140,
      grantCounts: 40,
      typeId: createdIds.testScoreTypes[0],
    },
  ];

  for (const ts of testScores) {
    try {
      await prisma.testScore.create({ data: ts });
      log(`‚úì Created test score entry`, colors.green);
    } catch (error: any) {
      log(`‚úó Failed to create test score: ${error.message}`, colors.red);
    }
  }

  // LicenseClassQuiz
  const licenseClassQuizzes = [
    { licenseClassId: createdIds.licenseClasses[0], quizId: createdIds.quizzes[0] },
    { licenseClassId: createdIds.licenseClasses[0], quizId: createdIds.quizzes[1] },
    { licenseClassId: createdIds.licenseClasses[1], quizId: createdIds.quizzes[0] },
  ];

  for (const lcq of licenseClassQuizzes) {
    try {
      await prisma.licenseClassQuiz.create({ data: lcq });
      log(`‚úì Linked license class to quiz`, colors.green);
    } catch (error: any) {
      log(`‚úó Failed to link license class to quiz: ${error.message}`, colors.red);
    }
  }
}

async function createUserInteractions() {
  log('\nüë§ Creating User Interaction Data (via Prisma)...', colors.cyan);

  // UserLicenses
  const userLicenses = [
    { userId: createdIds.users[0], licenseId: createdIds.licenses[0] },
    { userId: createdIds.users[1], licenseId: createdIds.licenses[1] },
    { userId: createdIds.users[2], licenseId: createdIds.licenses[0] },
  ];

  for (const ul of userLicenses) {
    try {
      await prisma.userLicense.create({ data: ul });
      log(`‚úì Assigned license to user`, colors.green);
    } catch (error: any) {
      log(`‚úó Failed to assign license: ${error.message}`, colors.red);
    }
  }

  // Results
  const results = [
    {
      userId: createdIds.users[0],
      quizId: createdIds.quizzes[0],
      answers: { q1: 4, q2: 5, q3: 3 },
      results: {
        archetypes: {
          investigative: 85,
          artistic: 60,
          realistic: 45,
        },
        topArchetype: 'investigative',
      },
    },
    {
      userId: createdIds.users[1],
      quizId: createdIds.quizzes[0],
      answers: { q1: 3, q2: 2, q3: 5 },
      results: {
        archetypes: {
          artistic: 90,
          social: 75,
          investigative: 50,
        },
        topArchetype: 'artistic',
      },
    },
  ];

  for (const result of results) {
    try {
      await prisma.result.create({ data: result });
      log(`‚úì Created quiz result for user`, colors.green);
    } catch (error: any) {
      log(`‚úó Failed to create result: ${error.message}`, colors.red);
    }
  }

  // UserQuestions
  const userQuestions = [
    { userId: createdIds.users[0], questionId: createdIds.questions[0], answers: { value: 4 } },
    { userId: createdIds.users[0], questionId: createdIds.questions[1], answers: { value: 5 } },
    { userId: createdIds.users[1], questionId: createdIds.questions[0], answers: { value: 3 } },
  ];

  for (const uq of userQuestions) {
    try {
      await prisma.userQuestion.create({ data: uq });
      log(`‚úì Recorded user answer to question`, colors.green);
    } catch (error: any) {
      log(`‚úó Failed to record user answer: ${error.message}`, colors.red);
    }
  }

  // UserArchetypes
  const userArchetypes = [
    { userId: createdIds.users[0], archetypeId: createdIds.archetypes[0], score: 85 },
    { userId: createdIds.users[0], archetypeId: createdIds.archetypes[1], score: 60 },
    { userId: createdIds.users[1], archetypeId: createdIds.archetypes[1], score: 90 },
    { userId: createdIds.users[1], archetypeId: createdIds.archetypes[2], score: 75 },
  ];

  for (const ua of userArchetypes) {
    try {
      await prisma.userArchetype.create({ data: ua });
      log(`‚úì Assigned archetype score to user`, colors.green);
    } catch (error: any) {
      log(`‚úó Failed to assign archetype: ${error.message}`, colors.red);
    }
  }

  // UserProfessions
  const userProfessions = [
    { userId: createdIds.users[0], professionId: createdIds.professions[0] },
    { userId: createdIds.users[0], professionId: createdIds.professions[1] },
    { userId: createdIds.users[1], professionId: createdIds.professions[4] },
  ];

  const userProfessionIds: string[] = [];
  for (const up of userProfessions) {
    try {
      const created = await prisma.userProfession.create({ data: up });
      userProfessionIds.push(created.id);
      log(`‚úì User saved profession to favorites`, colors.green);
    } catch (error: any) {
      log(`‚úó Failed to save profession: ${error.message}`, colors.red);
    }
  }

  // UserProfessionArchetypeTypes
  const userProfessionArchetypeTypes = [
    { userProfessionId: userProfessionIds[0], archetypeTypeId: createdIds.archetypeTypes[0], score: 82 },
    { userProfessionId: userProfessionIds[1], archetypeTypeId: createdIds.archetypeTypes[0], score: 88 },
    { userProfessionId: userProfessionIds[2], archetypeTypeId: createdIds.archetypeTypes[0], score: 75 },
  ];

  for (const upat of userProfessionArchetypeTypes) {
    try {
      await prisma.userProfessionArchetypeType.create({ data: upat });
      log(`‚úì Assigned archetype type score to user profession`, colors.green);
    } catch (error: any) {
      log(`‚úó Failed to assign archetype type: ${error.message}`, colors.red);
    }
  }
}

async function verifyData() {
  log('\nüîç Verifying Created Data...', colors.yellow);

  try {
    // Verify users
    const usersResponse = await api.get('/users');
    log(`‚úì Users in database: ${usersResponse.data.length}`, colors.green);

    // Verify professions
    const professionsResponse = await api.get('/professions');
    log(`‚úì Professions in database: ${professionsResponse.data.length}`, colors.green);

    // Check if professions have categories
    const professionWithCategory = professionsResponse.data.find((p: any) => p.category);
    if (professionWithCategory) {
      log(`‚úì Professions properly linked to categories`, colors.green);
    }

    // Verify archetypes
    const archetypesResponse = await api.get('/archetypes');
    log(`‚úì Archetypes in database: ${archetypesResponse.data.length}`, colors.green);

    // Check if archetypes have types
    const archetypeWithType = archetypesResponse.data.find((a: any) => a.archetypeType);
    if (archetypeWithType) {
      log(`‚úì Archetypes properly linked to types`, colors.green);
    }

    // Verify quizzes
    const quizzesResponse = await api.get('/quizzes');
    log(`‚úì Quizzes in database: ${quizzesResponse.data.length}`, colors.green);

    // Test GET by ID for one of each
    if (createdIds.users.length > 0) {
      const userResponse = await api.get(`/users/${createdIds.users[0]}`);
      log(`‚úì GET by ID works for users: ${userResponse.data.email}`, colors.green);
    }

    if (createdIds.professions.length > 0) {
      const professionResponse = await api.get(`/professions/${createdIds.professions[0]}`);
      log(`‚úì GET by ID works for professions: ${professionResponse.data.name.en}`, colors.green);
    }

    log('\n‚úÖ All data successfully created and verified!', colors.green);

    // Get counts from database
    const counts = {
      users: await prisma.user.count(),
      regions: await prisma.region.count(),
      categories: await prisma.category.count(),
      professions: await prisma.profession.count(),
      archetypeTypes: await prisma.archetypeType.count(),
      archetypes: await prisma.archetype.count(),
      quizzes: await prisma.quiz.count(),
      organizations: await prisma.organization.count(),
      licenseClasses: await prisma.licenseClass.count(),
      licenses: await prisma.license.count(),
      specs: await prisma.spec.count(),
      universities: await prisma.university.count(),
      questions: await prisma.question.count(),
      testScoreTypes: await prisma.testScoreType.count(),
      specUniversities: await prisma.specUniversity.count(),
      professionSpecs: await prisma.professionSpec.count(),
      professionArchetypes: await prisma.professionArchetype.count(),
      testScores: await prisma.testScore.count(),
      licenseClassQuizzes: await prisma.licenseClassQuiz.count(),
      userLicenses: await prisma.userLicense.count(),
      results: await prisma.result.count(),
      userQuestions: await prisma.userQuestion.count(),
      userArchetypes: await prisma.userArchetype.count(),
      userProfessions: await prisma.userProfession.count(),
      userProfessionArchetypeTypes: await prisma.userProfessionArchetypeType.count(),
    };

    log(`\nüìä Database Summary:`, colors.cyan);
    log(`\n   Core Entities:`, colors.yellow);
    log(`   ‚îú‚îÄ Users: ${counts.users}`, colors.blue);
    log(`   ‚îú‚îÄ Regions: ${counts.regions}`, colors.blue);
    log(`   ‚îú‚îÄ Categories: ${counts.categories}`, colors.blue);
    log(`   ‚îú‚îÄ Professions: ${counts.professions}`, colors.blue);
    log(`   ‚îú‚îÄ Archetype Types: ${counts.archetypeTypes}`, colors.blue);
    log(`   ‚îú‚îÄ Archetypes: ${counts.archetypes}`, colors.blue);
    log(`   ‚îî‚îÄ Quizzes: ${counts.quizzes}`, colors.blue);

    log(`\n   Organizations & Licenses:`, colors.yellow);
    log(`   ‚îú‚îÄ Organizations: ${counts.organizations}`, colors.blue);
    log(`   ‚îú‚îÄ License Classes: ${counts.licenseClasses}`, colors.blue);
    log(`   ‚îú‚îÄ Licenses: ${counts.licenses}`, colors.blue);
    log(`   ‚îî‚îÄ User Licenses: ${counts.userLicenses}`, colors.blue);

    log(`\n   Education:`, colors.yellow);
    log(`   ‚îú‚îÄ Specs: ${counts.specs}`, colors.blue);
    log(`   ‚îú‚îÄ Universities: ${counts.universities}`, colors.blue);
    log(`   ‚îú‚îÄ Spec Universities: ${counts.specUniversities}`, colors.blue);
    log(`   ‚îú‚îÄ Test Score Types: ${counts.testScoreTypes}`, colors.blue);
    log(`   ‚îî‚îÄ Test Scores: ${counts.testScores}`, colors.blue);

    log(`\n   Quizzes & Questions:`, colors.yellow);
    log(`   ‚îú‚îÄ Questions: ${counts.questions}`, colors.blue);
    log(`   ‚îú‚îÄ Results: ${counts.results}`, colors.blue);
    log(`   ‚îú‚îÄ User Questions: ${counts.userQuestions}`, colors.blue);
    log(`   ‚îî‚îÄ License Class Quizzes: ${counts.licenseClassQuizzes}`, colors.blue);

    log(`\n   Relationships:`, colors.yellow);
    log(`   ‚îú‚îÄ Profession Specs: ${counts.professionSpecs}`, colors.blue);
    log(`   ‚îú‚îÄ Profession Archetypes: ${counts.professionArchetypes}`, colors.blue);
    log(`   ‚îú‚îÄ User Archetypes: ${counts.userArchetypes}`, colors.blue);
    log(`   ‚îú‚îÄ User Professions: ${counts.userProfessions}`, colors.blue);
    log(`   ‚îî‚îÄ User Profession Archetype Types: ${counts.userProfessionArchetypeTypes}`, colors.blue);

  } catch (error: any) {
    log(`‚úó Verification failed: ${error.message}`, colors.red);
  }
}

async function main() {
  log('üöÄ Starting Database Seeding Process...', colors.yellow);
  log(`üì° API URL: ${API_URL}`, colors.blue);

  try {
    // Check if server is running
    await api.get('/');
    log('‚úì Server is running', colors.green);
  } catch (error) {
    log('‚úó Server is not running! Please start the server with: npm run start:dev', colors.red);
    process.exit(1);
  }

  try {
    // Create prerequisite data via Prisma
    await createRegions();
    await createCategories();
    await createArchetypeTypes();

    // Create main entities via API (testing POST endpoints)
    await createUsers();
    await createProfessions();
    await createArchetypes();
    await createQuizzes();

    // Create organizations and licenses
    await createOrganizations();
    await createLicenseClasses();
    await createLicenses();

    // Create education-related data
    await createSpecs();
    await createUniversities();
    await createTestScoreTypes();

    // Create questions for quizzes
    await createQuestions();

    // Create all relationship data
    await createRelationships();

    // Create user interaction data
    await createUserInteractions();

    // Verify everything (testing GET endpoints)
    await verifyData();

    log('\nüéâ Seeding completed successfully!', colors.green);
  } catch (error: any) {
    log(`\n‚ùå Seeding failed: ${error.message}`, colors.red);
    if (error.response) {
      log(`Response: ${JSON.stringify(error.response.data)}`, colors.red);
    }
    process.exit(1);
  } finally {
    await prisma.$disconnect();
  }
}

main();
